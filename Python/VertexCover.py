# -*- coding: utf-8 -*-
"""VertexCoverGA.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1geU5Loy8MW4paMFSQzySJngCURvqNtyf
"""

import glob
import time
import random
import matplotlib.pyplot as plt
import numpy as np
import copy
import pandas as pd
import matplotlib.pyplot as plt



# !cp -r /content/drive/MyDrive/ProgettoAI /content
# dataframe=pd.read_excel("/content/ProgettoAI/instaces-python.xlsx")
# print(dataframe)
# !unzip /content/ProgettoAI/wvcp-instances.zip
small_instaces=glob.glob("/mnt/c/Users/user/Desktop/vc_200_3000_04*")

# np.random.seed(12)



##SINGLE SOLUTION VIEW AS AN ARRAY OF {1,0}
class Individual():

    def __init__(self,individual,weight,calculate_fitness=True):
        self.individual=individual 
        if calculate_fitness:
          self.fitness=self.fitness_score(weight)
      
    def recalc_fitness(self,weight):
      self.fitness=self.fitness_score(weight)

    def fitness_score(self,weight_individual):
        global NUMBER_FE
        
        if NUMBER_FE==MAX_NUMBER_FE:
          raise Exception()
        NUMBER_FE+=1

        return np.sum(np.dot(self.individual,weight_individual))#+np.sum(self.individual*50.0))

    #OLD FITNESS
    def fitness_value(self,weight_individual):
        return np.sum(np.dot(self.individual,weight_individual))

    def __str__(self):
        return str(self.individual) 

    def __getitem__(self, item): 
         return self.individual[item]

    def __eq__(self, other):
        return np.allclose(self.individual,other.individual)

    def __lt__(self,other):
        return not np.allclose(self.individual,other.individual)

    def set_individual(self,index,value):
        self.individual[index]=value

    def is_valid_solution(self,matrix):
        ##check if is a vertex cover
        for idx in range(len(self.individual)):
            #sei il vertice è incluso non controllare la matrice di adiacenza
            if self.individual[idx]==1:
                continue
            ##prendi gli indici dei vertici non presenti nella vertex cover,controlla la matrice di adiacenza di tali vertici, se la somma è >=1 c'è un arco non incluso
            if self.single_edge_missing(matrix,idx)>=1:
                return False
        
        return True
    
    def single_edge_missing(self,matrix,idx):
        ##No. di archi non inclusi dato un nodo(idx)
        index_individual=(np.array(np.where(self.individual==0)).flatten())
        return np.sum(matrix[idx,[index_individual]])

    def full_edge_missing(self,matrix):
        ##No. di archi non inclusi in tutto il grafo
        sum_=0
        for idx in range(len(self.individual)):
            if self.individual[idx]==0:
                sum_+=self.single_edge_missing(matrix,idx)
        return sum_


class Population():

    def __init__(self,matrix,weight,population_size,solution_size,mutation_prob,log_epoch,type_crossover,max_generation=10000,verbose=False):
        self.population_size=population_size
        self.solution_size=solution_size
        self.max_generation=max_generation
        self.population=[]
        self.matrix=matrix
        self.weight=weight
        self.verbose=verbose
        self.log_epoch=log_epoch
        self.mutation_prob=mutation_prob
        self.type_crossover=type_crossover
        self.local_minima_stucked=False
        self.counter_local_minima=0
        self.k=np.array([10,40,70,100,130,160,190]).reshape(-1)
        print(self.k.shape)
        for _ in range(self.population_size):
            self.population.append(Individual(self.random_initialization(),weight,calculate_fitness=False))
        self.population=self.repair(self.population)
        
    def random_initialization(self):
        return np.random.randint(0,2,size=self.solution_size)

    def genetic_algorithm(self):
                  
        global solution_overall          #MIGLIOR SOLUZIONE           
        global history_mean              #MEDIA FITNESS
        # global MUTATION_PROB             #PROBABILITA DI MUTAZIONE
        global MUTATION_SIZE             #BIT DA FLIPPARE
        min_fitness_overall=MAX_INTEGER  #MIGLIOR FITNESS              
        min_value_prec_epoch=0

        for _ in range(self.max_generation):
            try:
                ##SELECTION
                # new_generation=self.selection_phase(self.population)

                ##CROSSOVER
                new_generation=self.crossover_new()

                ##MUTAZIONE
                new_generation=self.mutation(new_generation,_)

                ##RIPARE LE SOLUZIONI e CALC FITNESS
                new_generation=self.repair(new_generation)

                #RIORDINA
                new_generation=self.sort_population(new_generation)
                self.population=self.sort_population(self.population)
                #RICOMBINAZIONE mu+lambda 
                new_generation=new_generation[:int(self.population_size*PROP_NEW_GENERATION/100)]+self.population[:int(self.population_size*(100-PROP_NEW_GENERATION-RANDOM_SAMPLE)/100)]+random.sample(self.population,RANDOM_SAMPLE)                    
                # print(len(new_generation))    
                # self.population[:15]=new_generation[:15]     

                #NUOVA POP
                self.population=new_generation
                
                history_mean_epoch,min_value_epoch,individual_epoch_min=self.calculate_mean_fitness_pop(self.population)
                history_mean.append(history_mean_epoch)
                
                self.print_log(_,history_mean_epoch,min_value_epoch)

                # if self.local_minima_stucked:
                #     self.local_minima_stucked=False
                #     MUTATION_SIZE=1
                #     self.mutation_prob=0.05
                #     self.counter_local_minima=0

                # if min_value_prec_epoch==min_value_epoch:
                #     self.counter_local_minima+=1
                #     if self.counter_local_minima==5:
                #         self.local_minima_stucked=True
                #         MUTATION_SIZE=1
                #         self.mutation_prob=0.25
                #         self.population=self.pertubated_solution(self.population,10)
                #         self.population=self.repair(self.population)

                min_value_prec_epoch=min_value_epoch
                if min_value_epoch<min_fitness_overall:
                    min_fitness_overall=min_value_epoch
                    solution_overall=copy.deepcopy(individual_epoch_min)

                # if self.check_omogeneous_pop(self.population):
                # print(self.check_omogeneous_pop(self.population))
                
                # raise Exception()
                #     print(self.population)


            except Exception as e:
                print(e)
                # assert Individual(np.array([solution_overall]),self.weight,calculate_fitness=False).is_valid_solution==True
                return Individual(np.array([solution_overall]),self.weight,calculate_fitness=False),history_mean
           
        best_solution=Individual(array([solution_overall]),self.weight,calculate_fitness=False)
        # print("Soluzione migliore:",best_solution.fitness," Fitness:",min_fitness_overall)
        
        return best_solution,history_mean

    def print_log(self,epoch,history_mean_epoch,min_value_epoch):
        if self.verbose and epoch % self.log_epoch==0:
            print(f"GENERAZIONE: {epoch}, valore medio fit: {history_mean_epoch,min_value_epoch,self.mutation_prob}")

    def repair(self,pop):
        for item in pop:
            while not item.is_valid_solution(self.matrix):
                ##INDICI NON CONSIDERATI (==0) li flippo fin quando non raggiungo la vertex cover
                index_to_change=np.where(item.individual==0)[0]
                index_chose=np.random.randint(0,len(index_to_change))
                item.set_individual(index_to_change[index_chose],1)
               
            item.recalc_fitness(self.weight)
        return pop
    
    ###MODIFICARE
    def pertubated_solution(self,pop,k):
        for item in pop[:k]:
            idx_mutate=[np.random.randint(0,self.solution_size) for _ in range(self.solution_size)]
            for idx in idx_mutate:
                # prob=np.random.uniform(0,1)
                item.set_individual(idx,1-item.individual[idx])
            item.recalc_fitness(self.weight)
        return pop

    def check_omogeneous_pop(self,pop):

        return len(np.unique(pop))

    def mutation(self,new_generation,epoch):
        ##FLIPPO I BIT da 1->0 o 0->1 con MUTATION_PROB
        for item in new_generation:
            idx_mutate=[np.random.randint(0,self.solution_size) for _ in range(MUTATION_SIZE)]
            for idx in idx_mutate:
                prob=np.random.uniform(0,1)
                if prob <= self.mutation_prob:
                    item.set_individual(idx,1-item.individual[idx])

        return new_generation

    def crossover_new(self):
        new_gen=[]
        for i in range(self.population_size):
            #SELECTION PROP TO FITNESS
            fitness_sum=np.sum(np.array([i.fitness for i in self.population]))
            a, b = random.choices(self.population, [i.fitness/fitness_sum for i in self.population], k = 2)
            ## INCEST PREVENTING
            threshold=2
            if self.incest_preventing(a,b)>threshold:
                continue
            ##
            #  a, b = random.choices(self.population,  k = 2)
            if np.random.uniform(0,1)<=CROSSOVER_PROB:
                c,d=self.crossover_type(self.type_crossover,a,b)
                # if not self.duplicate_checking(c,new_gen):
                #     new_gen.append(c)
                # if not self.duplicate_checking(d,new_gen):
                #     new_gen.append(d)
                new_gen.append(c)
                new_gen.append(d)

        return new_gen

    def crossover_type(self,type_crossover,a,b):
        if type_crossover=='uniform':
            return self.crossover_uniforme(a,b)
        elif type_crossover=='2-point':
            return self.crossover_2point(a,b)
        elif type_crossover=='k-point':
            return self.crossover_k_point(a,b,self.k)
        else:
            Exception()

    def crossover_uniforme(self,a,b):
        p = [random.randint(0, 1) for _ in range(self.solution_size)]
        c = Individual(np.array([a if m == 0 else b for (a, b, m) in zip(a.individual, b.individual, p)]),self.weight,calculate_fitness=False)
        d = Individual(np.array([b if m == 0 else a for (a, b, m) in zip(a.individual, b.individual, p)]),self.weight,calculate_fitness=False)
        return c,d

    def crossover_2point(self,a,b):
        POINT_SPLIT_CROSSOVER=int(self.solution_size*1/3)#np.random.randint(0,self.solution_size)
        POINT_SPLIT_CROSSOVER_1=int(self.solution_size*2/3)#np.random.randint(POINT_SPLIT_CROSSOVER,self.solution_size)
        c=Individual(np.hstack([a[:POINT_SPLIT_CROSSOVER],b[POINT_SPLIT_CROSSOVER:POINT_SPLIT_CROSSOVER_1],a[POINT_SPLIT_CROSSOVER_1:]]),self.weight)
        d=Individual(np.hstack([a[:POINT_SPLIT_CROSSOVER],b[POINT_SPLIT_CROSSOVER:POINT_SPLIT_CROSSOVER_1],a[POINT_SPLIT_CROSSOVER_1:]]),self.weight)
        return c,d

    def crossover_k_point(self,a,b,k):
        c=copy.deepcopy(a)
        d=copy.deepcopy(b)
        for i in k:
            c,d=self.crossover_1point(c,d,i)
        return Individual(c,self.weight,calculate_fitness=False),Individual(d,self.weight,calculate_fitness=False)

    def crossover_1point(self,a,b,x):
        c=np.append(a[:x],b[x:])
        d=np.append(b[:x],a[x:])
        return c,d  

    def incest_preventing(self,a,b):
        return self.hamming_distance(a,b)

    def hamming_distance(self,a,b):
        return np.count_nonzero(a!=b)

    def duplicate_checking(self,x,new_gen):
        
        if x in new_gen:
           return True
        return False 

    def print_pop(self,pop):
        str_=""
        for _ in pop:
            str_+=_.__str__()+" Fit: "+str(_.fitness_score(self.weight)) +"\n"
        print(str_)
       
    def selection_phase(self,pop):
        return self.sort_population(pop)

    def compareSolution(self,sol):
        return sol.fitness

    def sort_population(self,pop):
        pop.sort(reverse=False,key=self.compareSolution)
        return pop
    
    def __str__(self,sort=True):
        if sort:
            self.sort_population()
        str_=""
        print("MATRICE INCIDENZA\n",self.matrix)
        print("WEIGHT VECTOR\n",self.weight)
        print("POPULATION")
        for _ in self.population[:20]:
            str_+=_.__str__()+" Fit: "+str(_.fitness_score(self.weight)) +"\n"
        
        return str_

    def check_valid_solution(self,pop):
        min_=MAX_INTEGER
        solution=[]
        for sol in pop:
            if sol.is_valid_solution(self.matrix):
                if min_ > sol.fitness:
                    min_ = sol.fitness
                    solution = sol
            
        return solution,min_
        
    def exact_solution(self):
        def binary_list(n):
            return [Individual(np.array(list('{:0{}b}'.format(i, n)),dtype=np.int32),self.weight) for i in range(2**n)]

        solution_min,fitness_min,=self.check_valid_solution(binary_list(20))
        print(f"Fitness: {fitness_min}, Individual: {solution_min}")
            
    def calculate_mean_fitness_pop(self,pop):
        min_=MAX_INTEGER
        solution=[]
        sum_=0
        for item in pop:
            sum_+=item.fitness
            if min_ > item.fitness:
              min_ = item.fitness
              solution = item
        
        return (sum_/len(pop)),min_,solution.individual
        

def reset_FE():
    global NUMBER_FE
    NUMBER_FE=0

def read_file(input_file):

    with open(input_file) as file:
        number_node=int(file.readline())
        vertex_weight=np.array((file.readline().strip().split("  ")),dtype=np.int32)
        matrix=np.zeros((number_node,number_node),dtype=np.int32)
        row=0
        for line in file.readlines():
            matrix[row]=line.strip().split(" ")
            row+=1
       
    return number_node,vertex_weight,matrix


dataframe_best_value=[]
for file_ in small_instaces:
  number_node,vertex_weight,matrix=read_file(file_)
  # print("#No.Vertici:",number_node,"\n#W:",vertex_weight)
  # print("UpperBound:",np.sum(vertex_weight))
  # print("#Matrix:\n",matrix)
  print(f"\
            #################\n\
            #################\n\
            ##### START #####\n\
            #################\n\
            #################\n{file_}")

  MEDIUM_VALUE=0
  NUMBER_FE=0
  MUTATION_SIZE=1
  MUTATION_PROB=0.15
  CROSSOVER_PROB=0.85
  MAX_NUMBER_FE=2*10**4
  PROP_NEW_GENERATION=85
  RANDOM_SAMPLE=10
  MAX_INTEGER=100000
  history_mean=[]
  solution_overall=[]
  start = time.time()

  for _ in range(1):
    population=Population(matrix,vertex_weight,population_size=64,solution_size=number_node,mutation_prob=MUTATION_PROB,log_epoch=25,type_crossover='uniform',verbose=True)
    sol=population.genetic_algorithm()
    reset_FE()
    print("SOLUZIONE:",np.where(sol[0].individual==1)[1])
    print("SOLUZIONE:",sol[0].individual)
    print(f"MIGLIORE FITNESS: {sol[0].fitness_score(vertex_weight)}, POP_SIZE: {population.population_size }, MUT_PROB: {population.mutation_prob}, MUTATION_SIZE: {MUTATION_SIZE}, PROB_NEW_GEN: {PROP_NEW_GENERATION}, CROSSOVER_PROB: {CROSSOVER_PROB}, CROSSOVER_TYPE: {population.type_crossover}  \n")
    MEDIUM_VALUE+=sol[0].fitness_score(vertex_weight)

  print(f"FITNESS MEDIA: {MEDIUM_VALUE/3}")
  print(f"FE: {NUMBER_FE}")
  print(f"\
          ###############\n\
          ###############\n\
          ##### END #####\n\
          ###############\n\
          ###############\n")
          
  end = time.time()
  print("ELAPSED TIME:",end - start)
  dataframe_best_value.append([file_,sol[0].fitness_value(vertex_weight),sol[0].individual])
  




# for i in pd_best_value:
#   print(i,pd_best_value[i])
# dataframe_value=pd.DataFrame(pd_best_value).rename(columns={0:'nome_file',1:'best_value'})
# print(dataframe_value)
# print(dataframe_value)

# print(dataframe_value[["nome_file",'best_value']])
# print(dataframe_value.iloc[0:10]['best_value'].mean())

# print(dataframe_value.iloc[10:20]['best_value'].mean())
# print(dataframe_value.iloc[20:30]['best_value'].mean())
# dataframe_value=dataframe_value.sort_values(by=['nome_file'])



# print(dataframe.dtypes)
# print(dataframe_value.dtypes)
# dataframe.merge(dataframe_value, on="nome_file")
# print(dataframe.join(dataframe_value,on=['nome_file']))


def small_instaces_plot(type_=None,type_instance=None):
  
  if type_ not in ["log_epoch.csv","log_min.csv","log_div.csv"]:
    print("ERRORE CSV")
    return

  if type_instance not in ["small_instance","medium_instance","large_instance"]:
    print("ERRORE INSTANCE")
    return
  dict_type={"log_epoch.csv": "val_medi","log_min.csv":"val_minimi","log_div.csv":"val_diversità"}
  dict_instance={"small_instance":["vc_20_60_","vc_20_120_","vc_25_150_"],
                 "medium_instance":["vc_100_500_","vc_100_2000_","vc_200_750_","vc_200_3000_"],
                 "large_instance":["vc_800_10000_"]}

  with open(type_, 'r') as temp_f:
    # get No of columns in each line
    col_count = [ len(l.split(";")) for l in temp_f.readlines() ]

    ### Generate column names  (names will be 0, 1, 2, ..., maximum columns - 1)
    column_names = [i for i in range(0, max(col_count))]

  # print(column_names)

  dataframe_tmp=pd.read_csv(type_,header=None,delimiter=";",names=range(max(column_names))).T
  dict_= {i:c for i,c in enumerate(dataframe_tmp.iloc[0])}
  dataframe=pd.read_csv(type_,header=None,delimiter=";",names=range(max(column_names))).T.rename(columns=dict_)
  dataframe.drop(0,inplace=True)
  dataframe=dataframe.dropna()
  plt.grid(True)
  
  

  for type_vc in dict_instance[type_instance]:
    dataframe[type_vc+type_]=0
    try:
      for _ in range(1,11):
        str_= "0" if _!=10 else ""
        dataframe[type_vc+type_]+=(dataframe[type_vc+str_+str(_)+".txt"].apply(lambda x: float(x.replace(",","."))))
      dataframe[type_vc+type_]=dataframe[type_vc+type_]/10
      plt.plot(range(len(dataframe)),dataframe[type_vc+type_],label=type_vc+dict_type[type_])
    
    except Exception as e:
      print(e)
  
  # print(dataframe) 
  plt.xlabel('Generazioni')
  plt.ylabel('Fitness_medie')
  plt.legend()
  
 
  return dataframe


# dataframe = small_instaces_plot("log_epoch.csv","medium_instance")
# dataframe = small_instaces_plot("log_div.csv","medium_instance")
# dataframe = small_instaces_plot("log_min.csv","medium_instance")
